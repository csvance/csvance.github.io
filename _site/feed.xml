<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>I'm an undergrad student interested in artificial intelligence and robotics. In my spare time I enjoy cooking, writing music and running.</description>
    <link>https://csvance.github.io/</link>
    <atom:link href="https://csvance.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 31 May 2018 20:14:34 -0500</pubDate>
    <lastBuildDate>Thu, 31 May 2018 20:14:34 -0500</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Keras/Tensorflow, TensorRT, and Jetson</title>
        <description>&lt;p&gt;nVidia’s Jetson platform is arguably the most powerful family of devices for deep learning at the edge. In order to achieve the full benefits of the platform, a framework called TensorRT drastically reduces inference time for supported network architectures and layers. However, nVidia does not currently make it easy to take your existing models from Keras/Tensorflow and deploy them on the Jetson with TensorRT. One reason for this is the python API for TensorRT only supports x86 based architectures. This leaves us with no real easy way of taking advantage of the benefits of TensorRT. However, there is a harder way that does work: To achieve maximum inference performance we can export and convert our model to .uff format, and then load it in TensorRT’s C++ API.&lt;/p&gt;

&lt;h2 id=&quot;1-training-and-exporting-to-pb&quot;&gt;1. Training and exporting to .pb&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Train your model&lt;/li&gt;
  &lt;li&gt;If using Jupyter, restart the kernel you trained your model in to remove training layers from the graph&lt;/li&gt;
  &lt;li&gt;Reload the models weights&lt;/li&gt;
  &lt;li&gt;Use an export function like the one in &lt;a href=&quot;https://github.com/csvance/keras-tensorrt-jetson/blob/master/training/training.ipynb&quot;&gt;this notebook&lt;/a&gt; to export the graph to a .pb file&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-converting-pb-to-uff&quot;&gt;2. Converting .pb to .uff&lt;/h2&gt;
&lt;p&gt;I suggest using the &lt;a href=&quot;https://github.com/chybhao666/TensorRT&quot;&gt;chybhao666/cuda9_cudnn7_tensorrt3.0:latest Docker container&lt;/a&gt; to access the script needed for converting a .pb export from Keras/Tensorflow to .uff format for TensorRT import.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/lib/python2.7/dist-packages/uff/bin
# List Layers and manually pick out the output layer
# For most networks it will be dense_x/BiasAdd, the last one that isn't a placeholder or activation layer
python convert_to_uff.py tensorflow --input-file /path/to/graph.pb -l

# Convert to .uff, replace dense_1/BiasAdd with the name of your output layer
python convert_to_uff.py tensorflow -o /path/to/graph.uff --input-file /path/to/graph.pb -O dense_1/BiasAdd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;More information on the .pb export and .uff conversion is available from &lt;a href=&quot;https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#exporttftouff&quot;&gt;nVidia&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-loading-the-uff-into-tensorrt-c-inference-api&quot;&gt;3. Loading the .uff into TensorRT C++ Inference API&lt;/h2&gt;
&lt;p&gt;I have created a generic class which can load the graph from a .uff file and setup TensorRT for inference while taking care of all host / device CUDA memory management behind the scenes. It supports any number of inputs and outputs and is available on my &lt;a href=&quot;https://github.com/csvance/keras-tensorrt-jetson/blob/master/inference/&quot;&gt;Github&lt;/a&gt;. It can be built with &lt;a href=&quot;https://developer.nvidia.com/nsight-eclipse-edition&quot;&gt;nVidia nSight Eclipse Edition&lt;/a&gt; using a remote toolchain &lt;a href=&quot;https://devblogs.nvidia.com/remote-application-development-nvidia-nsight-eclipse-edition/&quot;&gt;(instructions here)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;caveats&quot;&gt;Caveats&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Keep in mind that many layers are not supported by TensorRT 3.0. The most obvious omission is BatchNorm, which is used in many different types of deep neural nets.&lt;/li&gt;
  &lt;li&gt;Concatenate only works on the channel axis and if and only if the other dimensions are the same. If you have multiple paths for convolution, you are limited to concatenating them only when they have the same dimensions.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 22 May 2018 22:00:00 -0500</pubDate>
        <link>https://csvance.github.io/blog/keras-tensorrt-jetson.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/keras-tensorrt-jetson.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Turn Based Games and 1v1 DQNs</title>
        <description>&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;At this point, one would have to be living under a rock to have not heard of &lt;a href=&quot;https://deepmind.com&quot;&gt;DeepMind’s&lt;/a&gt; success at teaching itself to play Go by playing itself without any feature engineering. However, most available tutorials online about &lt;a href=&quot;https://deepmind.com/research/dqn/&quot;&gt;Deep Q Networks&lt;/a&gt; are coming from an entirely different angle: learning how to play various single player games in the &lt;a href=&quot;https://github.com/openai/gym&quot;&gt;OpenAI Gym&lt;/a&gt;. If one simply applies these examples to turn based games in which the AI learns by playing itself, a world of hurt is in store for several reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In standard DQN learning, the target reward is retrieved by using the next state after an action is taken. However, the next state in a turned based dueling game is used by the enemy of the agent who took the action. To further complicate matters, the generated next state from an action is in the perspective of the agent taking the action. If we attempt to implement standard DQN, we are training the agent with data used in incorrect game contexts and assigning rewards for the wrong perspective.&lt;/li&gt;
  &lt;li&gt;Many turn based dueling games only have a win condition rather than a score which can be used for rewards. This complicates both measuring a DQN’s performance and assigning rewards.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;state-and-perspective&quot;&gt;State and Perspective&lt;/h2&gt;
&lt;p&gt;First of all, in a game where an agent plays itself from multiple perspectives, we must be careful the correct perspective is provided when making predictions or training discounted future rewards. For example, let us consider the game &lt;a href=&quot;https://en.wikipedia.org/wiki/Connect_Four&quot;&gt;Connect Four&lt;/a&gt;. Instead of viewing the game as a battle between a red agent and a black agent, we could consider it from the perspective the agents viewpoint at the state being considered. For example, when the agent who takes the second turn blocks the agent who went first, the following next state is generated:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/perspective_a.png&quot; alt=&quot;perspective&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However, this next state wouldn’t be used by the agent who went second to take an action. It is going to be used by the agent who went first, but it needs to be inverted to their perspective before it can be used:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/perspective_b.png&quot; alt=&quot;perspective&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However, this is not the only tweak needed to get DQN working with a dueling turn based game. Let us recall how the discounted future reward is calculated:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;future_reward = reward + gamma * amax(predict(next_state))&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;gamma: discount factor, for example 0.9&lt;/li&gt;
  &lt;li&gt;reward: the reward the agent recieved for taking an action&lt;/li&gt;
  &lt;li&gt;next_state: the state generated from applying an action to the original state&lt;/li&gt;
  &lt;li&gt;amax selects: highest value from the result&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Remember, next_state will be the enemy agent’s state. So if we simply implement this formula, we are predicting the discounted future reward that the enemy agent might receive, not our own. We must predict one more state into the future in order to propagate the discounted future reward:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;# We must invert the perspective of next_state so it is in the perspective of the enemy of the player who took the action which resulted in next_state&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;next_state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invert_perspective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Predict the action the enemy is most likely to take&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;enemy_action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Apply the action and invert the perspective back to the original one&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;true_next_state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next_state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enemy_action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;true_next_state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invert_perspective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Finally calculate discounted future reward&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;future_reward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gamma&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;true_next_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I have also tried subtracting the enemy reward from the reward that took the original action, but have not been able to measure good long or short term results with this policy.&lt;/p&gt;

&lt;h2 id=&quot;win-conditions-and-rewards&quot;&gt;Win Conditions and Rewards&lt;/h2&gt;
&lt;p&gt;Another problem with certain board games such as Connect Four is that they have no objective way of keeping score. There is only reward for victory and punishment for failure. I have had luck using 1.0 for victory, -1.0 for failure, and 0.0 for all other moves. Samples for duplicate games in a row and ties should be discarded as they don’t contain any useful information and will only serve to pollute our replay memory.&lt;/p&gt;

&lt;h2 id=&quot;measuring-performance&quot;&gt;Measuring Performance&lt;/h2&gt;
&lt;p&gt;One major challenge of DQNs with only win / loss conditions is measuring the networks performance over time. I have found a few ways to do this, including having the agent play a short term reward maximizing symbolic AI every N games as validation. If our agent cannot beat an agent that only thinks in the short term, then we need to continue making changes to the network structure, hyper-parameters, and feature representation. Beating this short sighted AI consistently should be our first goal.&lt;/p&gt;

&lt;h2 id=&quot;network-stability&quot;&gt;Network Stability&lt;/h2&gt;
&lt;p&gt;A common mistake creating a DQN is making the network have too few dimensions to begin with. This can cause serious aliasing in our predictions, resulting in an unstable network. Generally speaking, it is better to start with a wide network and testing how much the network can be slimmed down.&lt;/p&gt;

&lt;p&gt;We must also make sure our training data and labels are formatted in a way to ensure stability. Rewards should be normalized in the [-1., 1.] range, and any discounted future reward which is outside of this range should be clipped.&lt;/p&gt;

&lt;p&gt;Another factor in network stability is our experience replay buffer size. Too small and our network will forget past things it learned, and too big and it will take excessive time to learn. I find it is generally its better to start smaller while testing if the network is able to learn simple gameplay, and increasing it as training time increases and we want to insure network stability. People smarter than I such as Schaul et al. (2017) have proposed methods to optimize the size of the experience replay buffer: &lt;a href=&quot;https://arxiv.org/abs/1511.05952&quot;&gt;Prioritized Experience Replay&lt;/a&gt; which may be worth investigating if you are unsure how to tune this.&lt;/p&gt;

&lt;p&gt;Another factor to consider is the optimizer learning rate. A high learning rate can create instabilities in the neural networks state approximation behavior, resulting in all kinds of catastrophic forgetfulness. Starting at 0.001 is a good idea, and if you note instabilities with this try decreasing it from there. I find that 0.0001 works optimally for longer training sessions.&lt;/p&gt;

&lt;p&gt;Finally, techniques used in deep neural networks such as dropout and batchnorm have a negative impact on Deep-Q Learning. I suggest watching &lt;a href=&quot;https://www.youtube.com/watch?v=fevMOp5TDQs&quot;&gt;Deep RL Bootcamp Lecture 3: Deep Q-Networks&lt;/a&gt; if you are interested in more information on this.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Deep Q Learning proves to be both extremely interesting and challenging. While I am not completely happy with my own results in training a DQN for Connect Four, I think it is at least worth posting some of the things I have learned from the experience. My current agent can be found at the link below.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/csvance/deep-learning-connect-four&quot;&gt;Github: DQN AI for Connect Four&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://keon.io/deep-q-learning/&quot;&gt;Deep Q-Learning with Keras and Gym&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=fevMOp5TDQs&quot;&gt;Deep RL Bootcamp Lecture 3: Deep Q-Networks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 09 Jan 2018 12:04:00 -0600</pubDate>
        <link>https://csvance.github.io/blog/turn-based-games-1v1-dqn.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/turn-based-games-1v1-dqn.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>The RNN Sequence Prediction Seed Problem and How To Solve It</title>
        <description>&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;There are many &lt;a href=&quot;https://machinelearningmastery.com/text-generation-lstm-recurrent-neural-networks-python-keras/&quot;&gt;tutorials&lt;/a&gt; on how to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrent_neural_network&quot;&gt;Recurrent Neural Networks&lt;/a&gt; and use them for sequence generation. However, most of these tutorials show an example where an initial seed value must be used to start the generation process. This is highly impractical for a query response generation scheme. Luckily, there is a fairly easy way to solve this involving how we format our training data.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;h3 id=&quot;empty-item&quot;&gt;Empty Item&lt;/h3&gt;
&lt;p&gt;First of all, we need to make sure we have a dummy value which represents an empty sequence item. It is convenient to use zero for this, because most padding functions are going to pad with zeros, and functions like np.zeros make it easy to initialize this. We will represent this value as NULL for simplicity.&lt;/p&gt;
&lt;h3 id=&quot;end-of-sequence-item&quot;&gt;End of Sequence Item&lt;/h3&gt;
&lt;p&gt;We need a second special value for marking the end of a sequence. Call it EOS for short, and it can be whatever value you want provided it stays consistent.&lt;/p&gt;
&lt;h3 id=&quot;sequence-steps&quot;&gt;Sequence Steps&lt;/h3&gt;
&lt;p&gt;Instead of feeding entire sequences for training, we are going to step through each sequence, generating subsequences starting with all empty values and adding one more item in each step. The label for each sequence will simply be the next word in the sequence, or &lt;EOS&gt; if we reach the end of the sequence. For example, take the sequence &quot;The quick brown fox jumps over the lazy dog. This will break down into the following sequences:&lt;/EOS&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
&quot;NULL NULL NULL NULL NULL NULL NULL NULL NULL&quot; -&amp;gt; The
&quot;The NULL NULL NULL NULL NULL NULL NULL NULL&quot; -&amp;gt; quick
&quot;The quick NULL NULL NULL NULL NULL NULL NULL&quot; -&amp;gt; brown
&quot;The quick brown NULL NULL NULL NULL NULL NULL&quot; -&amp;gt; fox
&quot;The quick brown fox NULL NULL NULL NULL NULL&quot; -&amp;gt; jumps
&quot;The quick brown fox jumps NULL NULL NULL NULL&quot; -&amp;gt; over
&quot;The quick brown fox jumps over NULL NULL NULL&quot; -&amp;gt; the
&quot;The quick brown fox jumps over the NULL NULL&quot; -&amp;gt; lazy
&quot;The quick brown fox jumps over the lazy NULL&quot; -&amp;gt; dog
&quot;The quick brown fox jumps over the lazy dog&quot; -&amp;gt; EOS
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;sequence-size&quot;&gt;Sequence Size&lt;/h3&gt;
&lt;p&gt;If you have a sequence larger than your maximum size, start removing the first element before you append a new one. This will have no bearing on prediction because the network will learn how to handle this.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We can now train the network and start by feeding it a sequence filled with NULLs to predict the first value. Here is an example doing this using &lt;a href=&quot;https://keras.io&quot;&gt;Keras&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/csvance/armchair-expert/blob/master/models/structure.py&quot;&gt;Preprocessing &amp;amp; Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 29 Dec 2017 12:04:00 -0600</pubDate>
        <link>https://csvance.github.io/blog/rnn-seed-problem.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/rnn-seed-problem.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Hello World!</title>
        <description>&lt;p&gt;Hi, and welcome to my portfolio and blog. I will be chronicling my explorations in machine learning, artificial intelligence, and software engineering here.&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Dec 2017 13:40:48 -0600</pubDate>
        <link>https://csvance.github.io/blog/hello-world.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/hello-world.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
