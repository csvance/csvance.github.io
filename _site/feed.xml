<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>I'm an undergrad student with a passion for computer vision and machine learning.</description>
    <link>https://csvance.github.io/</link>
    <atom:link href="https://csvance.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 13 Jul 2019 12:07:25 -0500</pubDate>
    <lastBuildDate>Sat, 13 Jul 2019 12:07:25 -0500</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Ordinary Differential Equations: Limit Sets and Long Term Behavior</title>
        <description>&lt;p&gt;I wrote my Ordinary Differential Equations term project in &lt;a href=&quot;https://www.latex-project.org&quot;&gt;LaTeX&lt;/a&gt; and thought it would be fun to see if I could convert it to markdown and post it here. Apparently &lt;a href=&quot;https://www.mathjax.org&quot;&gt;MathJax&lt;/a&gt; makes this easy, so here it is!&lt;/p&gt;

&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;This paper will address the long-term behavior of systems of ordinary
differential equations (hereafter ODEs), including the first and second
dimensional cases. The specific behavior of interest is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lim_{t\to\infty} y(t) \neq\pm\infty&lt;/script&gt;

&lt;p&gt;where ${y}(t)$ is a solution to
a system of ODEs. Families of solutions will be considered analytically
and numerically for behavior such as periodic orbits and fixed points.
The considered problems will be plotted and have their limit sets
enumerated.&lt;/p&gt;

&lt;h1 id=&quot;dimension-d--1&quot;&gt;Dimension D = 1&lt;/h1&gt;

&lt;p&gt;Consider the first order linear ODE:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y\prime = y&lt;/script&gt;

&lt;p&gt;By simply looking
at the equation, it can be observed that it is autonomous (no
independent variable is present in the ODE). From this we know that the
behavior of the solution does not change with the independent variable
$t$. Solving the differential equation through integration provides a
solution:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y(t) = C_1e^t&lt;/script&gt;

&lt;p&gt;Analytically it can be observed that with an
initial condition of $y(0) = 0$ that $C_1 = 0$. Consequentially for any
value of $t$, $y(t) = 0$:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lim_{t\to\infty} y(t) = 0 \textrm{ where } y(0) = 0&lt;/script&gt;

&lt;p&gt;For any other
initial condition, it can observed that $y(t)$ will grow without bounds:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/d1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Because $y\prime = y$ is a one dimensional system, its phase plane only
has a single dimension $y(t)$. The limit set includes all points in this
dimension such that:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lim_{t\to\infty} y(t) \neq\pm\infty | t \in \mathbb{R}&lt;/script&gt;

&lt;p&gt;It directly
follows that the limit set for the ODE $y\prime = y$ is $\{(0)\}$.&lt;/p&gt;

&lt;h1 id=&quot;dimension-d--2&quot;&gt;Dimension D = 2&lt;/h1&gt;

&lt;h4 id=&quot;damped-vibrating-spring&quot;&gt;Damped Vibrating Spring&lt;/h4&gt;

&lt;p&gt;Consider the second order system of linear ODEs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
y\prime=v\\
v\prime=-4y-2v
\end{array}&lt;/script&gt;

&lt;p&gt;This is derived from a second order unforced and damped
harmonic motion ODE $y\prime\prime + 2cy\prime + \omega_0^2 = 0$ where
$c = 1$ and $\omega_0 = 2$. When $c &amp;lt; \omega_0$ the system is
over-damped. Knowing this, it should be expected that all solutions in
the phase plane converge to a single point as the damping term overtakes
the rest of the system. Consequentially, the limit set of the system
contains the point of convergence for all solutions as $t\to\infty$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/d2_a_p.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_a_v.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_a_ph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Plotting the solution curves displays behavior typical of a spiral sink,
and the trace determinant plane confirms it: $D(A) = 4,T(A) = -2$. Due
to this behavior, all sollution curves in the phase plane converge to a
single two dimensional equilibrium point $(0, 0)$ as $t\to\infty$. It
follows that the limit set for this ODE is $\{(0, 0)\}$. While this
limit set resembles the limit set of the one dimensional case, it should
be noted that the ODE in the one dimensional case only had a non
infinite solution as $t\to\infty$ with a single IVP, where as every IVP
in the two dimensional case converged towards the origin.&lt;/p&gt;

&lt;h4 id=&quot;undamped-vibrating-spring&quot;&gt;Undamped Vibrating Spring&lt;/h4&gt;

&lt;p&gt;Consider the second order system of linear ODEs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
y\prime=v\\
v\prime=-4y
\end{array}&lt;/script&gt;

&lt;p&gt;This is derived from a second order unforced and undamped
harmonic motion ODE $y\prime\prime + 2cy\prime + \omega_0^2 = 0$ where
$c = 0$ and $\omega_0 = 2$. When $c = 0$ the system is undamped. Knowing
this, it should be expected that all solutions of $y(t)$ and
$y\prime(t)$ to be repeating in nature, so they should form an ellipse
like shape in the phase plane. Consequentially, the limit set of the
system should contain as many members as there are solutions to initial
value problems. A plot confirms these suspicions:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/d2_b_p.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_b_v.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_b_ph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This system clearly exhibits a center behavior, which is confirmed by
the trace determinant plane: $D(A) = 4,T(A) = 0$. It follows that the
limit set contains every curve in the phase plane formed by the general
solution of the ODE and its derivative:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
y(t) = C_1cos(2t) + C_2sin(2t)\\
y\prime(t) = -C_1(2sin(2t)) + C_2(2cos(2t))\\
\end{array}&lt;/script&gt;

&lt;p&gt;It should also be noted that the origin of the phase plane
$(0, 0)$ is in the limit set. This can easily be verified by solving the
initial value problem for $y(0) = 0, y\prime(0) = 0$. Finally, the limit
set for this ODE can be characterized by the two behaviors mentioned
above:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;$(y=0,y\prime=0)$: Solutions that start at the origin stay at the
origin as $t\to\infty$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$y\ne0,y\prime \ne 0$: Solutions that start outside of the origin
stay in a periodic solution curve as $t\to\infty$ which is defined
by the system solution for the initial value problem.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;undamped-pendulum&quot;&gt;Undamped Pendulum&lt;/h4&gt;

&lt;p&gt;Consider the second order system of nonlinear ODEs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
\theta\prime=\omega\\
\omega\prime=-sin(\theta)\\
\end{array}&lt;/script&gt;

&lt;p&gt;This is derived from the undamped pendulum ODE
$\theta\prime\prime = -sin(\theta)$. There are quite a few initial
conditions $p_0$ to consider.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;For $p_0\in\{ (\theta = 2n\pi, \omega_0 = 0)| n\in\mathbb{Z} \}$,
the phase plane solution should be a single point $p_0$ as the
pendulum has no energy.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For $p_0\in\{\theta_0 \ne 0, \omega_0 = 0\}$ the phase plane
solution should look like a center around a point
$p_c \in \{ (\theta = 2n\pi, \omega)| n\in\mathbb{Z} \}$ as the
pendulum converts potential energy to velocity, back to potential
energy, and finally changing directions to repeat the process.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For $p_0\in\{(\theta_0=0,\mid\omega_0\mid \lessapprox 2.00027)\}$ ,
the pendulum should behave like case two.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For $p_0\in\{(\theta_0=0,\mid\omega_0\mid \gtrapprox 2.00027)\}$,
the pendulum no longer changes direction and
$\lim_{t\to\infty} \theta(t) = \pm\infty$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For
$p_0\in\{ (\theta_0 = \pi + 2n\pi, \omega_0 = 0)| n\in\mathbb{Z} \}$,
the phase plane solution should be a single point $p_0$ as the
pendulum needs a nudge in either direction to start moving.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The plots above confirm the predicted behavior of solutions. The limit
set can be broken down into three different cases:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/d2_c_p.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_c_v.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_c_ph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Solutions where $\omega$ contains positive and negative values
behave as a center around some point
$p_c \in \{(\theta_0 = 2n\pi, \omega_0 = 0) | n\in\mathbb{Z} \}$.
This is confirmed by looking at the trace determinant plane for the
center equilibrium: $D(J)=1, T(J)=0$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$p_0 \in \{(\theta_0 = 2n\pi, \omega_0 = 0) | n\in\mathbb{Z} \}$:
Solutions to this IVP stay at the angle they started at as
$t\to\infty$. These equilibrium points are shared with case one.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\{ (\theta_0 = \pi + 2n\pi, \omega_0 = 0) | n\in\mathbb{Z} \}$:
Solutions to this IVP stay at the angle they started at as
$t\to\infty$. These equilibrium points are saddle points in the
trace determinant plane: $D(J)=-1, T(J)=0$.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It is important to keep in mind that solutions where
$\lim_{t\to\infty} \omega(t) \neq\pm\infty$ are not a member of the
limit set if $\lim_{t\to\infty} \theta(t) = \pm\infty$. This excludes
any solutions for which $\omega$ is exclusively $&amp;gt; 0$ or $&amp;lt; 0$ as
$t\to\infty$. However, we can still make a definitive statement as to
the behavior of $\omega$ as $t\to\infty$.&lt;/p&gt;

&lt;h4 id=&quot;damped-pendulum&quot;&gt;Damped Pendulum&lt;/h4&gt;

&lt;p&gt;Consider the second order system of nonlinear ODEs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
\theta\prime=\omega\\
\omega\prime=-sin(\theta) - \frac{1}{2}\omega\\
\end{array}&lt;/script&gt;

&lt;p&gt;This is derived from the damped pendulum ODE
$\theta\prime\prime = -sin(\theta) - c\theta\prime$. A reasonable guess
as to its behavior would be behaving much like the undamped case except
in the cases that resulted in endless oscillation. On the phase plane,
these cases should converge to
$(\theta_0 = 2n\pi | n\in\mathbb{Z}, \omega_0 = 0)$ instead.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/d2_d_p.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_d_v.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_d_ph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Based on analysis of the system and observed behavior of the numerical
plot, a limit set can be constructed:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;When $\{(\theta_0 = \pi + 2n\pi, \omega_0=0)| n\in\mathbb{Z}\}$,
solutions remain where they started. This can be verified because
these values are in the set of equilibrium points. The trace
determinant shows saddle point behavior for the set of initial
conditions: $D(J)=1, T(J)=-\frac{1}{2}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All solutions not included in case one converge to a spiral sinks in
the set of $\{(\theta = 2n\pi, \omega = 0)| n\in\mathbb{Z}\}$
depending on initial conditions. This can be confirmed by
recognizing that equilibrium points which follow the same pattern
are all in the spiral sink region of the trace determinant plane:
$D(J)=1, T(J)=-\frac{1}{2}$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;competing-species&quot;&gt;Competing Species&lt;/h4&gt;

&lt;p&gt;Consider the second order system of nonlinear ODEs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
x\prime = (1 - x - y)x\\
y\prime = (4 - 2x -7y)y\\
\end{array}&lt;/script&gt;

&lt;p&gt;In a competing species system, the populations of two
species interact with each other and/or themselves. To analyze such a
system for long term behavior, the equilibrium points should first be
considered:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
(1-x-y)x = 0\\
(4-2x-7y)y=0\\
\end{array}&lt;/script&gt;

&lt;p&gt;Solving for the x-nullcline, y-nullcline, and nullcline
provides the set
$\{(0, 0), (1, 0), (0, \frac{4}{7}), ({\frac{3}{5}, \frac{2}{5}})\}$
Next, the system is linearized by computing the Jacobian:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcl}
J = \begin{pmatrix}
\frac{\partial}{\partial x}(1 - x - y)x &amp; \frac{\partial}{\partial y}(1 - x - y)x  \\
\frac{\partial}{\partial x}(4 - 2x - 7y)y &amp; \frac{\partial}{\partial y}(4 - 2x - 7y)y
\end{pmatrix}\\
J = \begin{pmatrix}
1 - y - 2x &amp; -x\\
-2y &amp; 4-14y-2x
\end{pmatrix}\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Next the Jacobian is used to examine the equilibrium in
the trace determinant plane:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
(0, 0):\textrm{ Nodal Source}\\
D_{0, 0} = det_{0, 0}(J) = 4\\
T_{0, 0} = tr_{0, 0}(J) = 5\\
\\
(1, 0):\textrm{ Saddle Point}\\
D_{1, 0} = det_{1, 0}(J) = -2\\
T_{1, 0} = tr_{1, 0}(J) = 1\\
\\
(0, \frac{4}{7}):\textrm{ Saddle Point}\\
D_{0, \frac{4}{7}} = det_{0, \frac{4}{7}}(J) = 0\\
T_{0, \frac{4}{7}} = tr_{0, \frac{4}{7}}(J) = -3\\
\\
(\frac{3}{5}, \frac{2}{5}):\textrm{ Nodal Sink}\\
D_{\frac{3}{5}, \frac{2}{5}} = det_{\frac{3}{5}, \frac{2}{5}}(J) = \frac{6}{5}\\
T_{\frac{3}{5}, \frac{2}{5}} = tr_{\frac{3}{5}, \frac{2}{5}}(J) = -\frac{17}{5}\\
\end{array}&lt;/script&gt;

&lt;p&gt;Plotting for several initial value problems, a few things
can be observed:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;When $x$ and $y$ have an initial values $&amp;gt; 0$, their solutions
gravitate towards $\frac{3}{5}$ and $\frac{2}{5}$. This is
consistent with the predicted nodal sink behavior.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Initial values of $x$ and $y$ that start at zero stay at zero, which
is expected when starting at the center of a nodal source.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When $y = 0$, Initial values of $x &amp;gt; 0$ gravitate towards one. This
makes sense when $y = 0$ reduces the first equation to
$x\prime = x(x - 1)$ which clearly has a root of $1$. It follows
that it has an equilibrium point there as well. Examining the trace
determinant of $(1, 0)$ places it in the region of saddle points.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When $x = 0$, $y$ gravitates towards $\frac{4}{7}$. This makes sense
considering the second equation is reduced to $y\prime = y(4 - 7y)$,
which has a root $\frac{4}{7}$. Examining the trace determinant of
this point it clearly falls into the region of saddle points.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/d2_e_ph.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_e_1_1.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_e_1_0.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_e_0_1.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/figures/d2_e_0_0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Considering the above, the limit set contains individual points on the
phase plane:
$\{(0, 0), (1, 0), (0, \frac{4}{7}), ({\frac{3}{5}, \frac{2}{5}})\}$.
This system contains more non periodic individual points in its limit
set than any previously examined system while containing no center
curves.&lt;/p&gt;

&lt;h4 id=&quot;van-der-pols-equation&quot;&gt;Van der Pol’s Equation&lt;/h4&gt;

&lt;p&gt;Consider the following system of nonlinear ODEs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
x\prime = 2x-y-x^3\\
y\prime = x\\
\end{array}&lt;/script&gt;

&lt;p&gt;To analyze this system, first the equilibrium points need
to be solved using the intersection of the nullclines:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{array}{lcl}
2x-y-x^3 = 0\\
x = 0\\
S = \\{(0, 0)\\}\\
\end{array}&lt;/script&gt;

&lt;p&gt;Next, the system is linearized and the trace determinant
of the equilibrium point computed:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcl}
J = \begin{pmatrix}
\frac{\partial}{\partial x}2x-y-x^3 &amp; \frac{\partial}{\partial y} 2x-y-x^3\\
\frac{\partial}{\partial x}x &amp; \frac{\partial}{\partial y} x
\end{pmatrix}\\
\\
J = \begin{pmatrix}
2 - 3x^2 &amp; -1\\
1 &amp; 0
\end{pmatrix}\\
\\
(0, 0):\textrm{ Special Case / Nodal Source}\\
D_{0, 0} = det_{0, 0}(J) = 1\\
T_{0, 0} = tr_{0, 0}(J) = 2\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;The equilibrium point is a special case with real
eigenvalues and $T^2 = 4D$. Plotting the phase plane reveals atypical
behavior:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/d2_f_ph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are two clear behaviors here, both of which are clearly members of
the limit set:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;For $(x = 0, y = 0)$, the solution does not leave the origin of the
phase plane.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All other initial values seem to converge into the exact same
periodic closed curve. This is different than previous center
periodic solutions where there were infinitely many different paths
depending on initial conditions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Setting the initial condition to a part of the closed loop yields the
following result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/d2_f_loop.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;extra-work&quot;&gt;Extra Work&lt;/h1&gt;

&lt;h4 id=&quot;approximating-van-der-pols-solution-curve&quot;&gt;Approximating Van der Pol’s Solution Curve&lt;/h4&gt;

&lt;p&gt;While I wasn’t able to find a solution to Van der Pol’s equation, I was
not content walking away without at least approximating a solution. Here
are the steps I took to approximate a curve. First, we apply a rotation
using a linear transformation with $\theta=\frac{\pi}{16}$ (Matrix $A$
is the output of ODE45)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/fit_rotate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcl}
R = \begin{pmatrix}
cos(\theta) &amp; -sin(\theta) \\
sin(\theta) &amp; cos(\theta) \\
\end{pmatrix}\\\\
X = AR
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Next a shear transform is applied with $k = 0.03$:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/fit_shear.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcl}
K = \begin{pmatrix}
1 &amp; k \\
0 &amp; 1 \\
\end{pmatrix}\\\\
X = XK
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/fit_pretrans.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A polynomial fit is found with $n = 26$. Next we apply the inverse of
the linear transformations previously applied.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/fit_pretest.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The moment of truth:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/figures/fit_test.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;While the fit may not be anywhere near perfect, it is a good first
attempt and perhaps worthy of more exploration at a later time.&lt;/p&gt;

</description>
        <pubDate>Thu, 09 May 2019 07:00:00 -0500</pubDate>
        <link>https://csvance.github.io/blog/ode-limit-sets-long-term-behavior.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/ode-limit-sets-long-term-behavior.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Installing and using Tensoflow with TF-TRT on the Jetson Nano</title>
        <description>&lt;p&gt;One of the great things to release alongside the &lt;a href=&quot;https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-nano/&quot;&gt;Jetson Nano&lt;/a&gt; is &lt;a href=&quot;https://developer.nvidia.com/embedded/jetpack&quot;&gt;Jetpack 4.2&lt;/a&gt;, which includes support for &lt;a href=&quot;https://developer.nvidia.com/tensorrt&quot;&gt;TensorRT&lt;/a&gt; in python. One of the easiest ways to get started with TensorRT is using the &lt;a href=&quot;https://github.com/tensorflow/tensorrt&quot;&gt;TF-TRT interface&lt;/a&gt;, which lets us seamlessly integrate TensorRT with a &lt;a href=&quot;http://tensorflow.org&quot;&gt;Tensorflow&lt;/a&gt; graph even if some layers are not supported. Of course this means we can easily accelerate &lt;a href=&quot;https://keras.io&quot;&gt;Keras&lt;/a&gt; models as well!&lt;/p&gt;

&lt;p&gt;nVidia now provides a &lt;a href=&quot;https://devtalk.nvidia.com/default/topic/1038957/jetson-tx2/tensorflow-for-jetson-tx2-/&quot;&gt;prebuilt Tensorflow&lt;/a&gt; for Jetson that we can install through pip, but we also need to make sure certain dependencies are satisfied.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install python3-numpy python3-markdown python3-mock python3-termcolor python3-astor libhdf5-dev&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Follow the instructions here to install tensorflow-gpu on Jetpack 4.2: &lt;a href=&quot;https://devtalk.nvidia.com/default/topic/1038957/jetson-tx2/tensorflow-for-jetson-tx2-/&quot;&gt;https://devtalk.nvidia.com/default/topic/1038957/jetson-tx2/tensorflow-for-jetson-tx2-&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now that Tensorflow is installed on the Nano, lets load a pretrained MobileNet from Keras and take a look at its performance with and without TensorRT for binary classification.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tensorflow.keras&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;keras&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tensorflow.keras.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tensorflow.keras.layers&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flatten&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mobilenet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keras&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applications&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mobilenet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MobileNet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include_top&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;224&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;224&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'imagenet'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mobilenet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;summary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flatten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mobilenet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;new_output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'sigmoid'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mobilenet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outputs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;summary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# TODO: Train your model for binary classification task&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mobilenet.h5'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next we can execute inferences with different settings using &lt;a href=&quot;https://gist.github.com/csvance/47ec78d67894c0d454ca98029d4d323c&quot;&gt;this script&lt;/a&gt; (thanks to &lt;a href=&quot;https://github.com/jeng1220&quot;&gt;jeng1220&lt;/a&gt; for the &lt;a href=&quot;https://github.com/jeng1220/KerasToTensorRT&quot;&gt;Keras to TF-TRT code&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;You will need to install plac to run the script: &lt;code class=&quot;highlighter-rouge&quot;&gt;pip3 install --user plac&lt;/code&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# Tensorflow Standard Inference&lt;/span&gt;
python3 tftrt_inference.py -S 30 -T TF mobilenet.h5
&lt;span class=&quot;c&quot;&gt;# Time = 4.19 s&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Samples = 30&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# FPS = Samples / Time = 30 / 4.19 = 7.16 FPS&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# TensorRT FP32 Inference&lt;/span&gt;
python3 tftrt_inference.py -S 30 -T FP32 mobilenet.h5
&lt;span class=&quot;c&quot;&gt;# Time = 0.96 s&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Samples = 30&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# FPS = Samples / Time = 30 / 0.96 = 31.3 FPS&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# TensorRT FP16 Inference&lt;/span&gt;
python3 tftrt_inference.py -S 30 -T FP16 mobilenet.h5
&lt;span class=&quot;c&quot;&gt;# Time = 0.84 s&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Samples = 30&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# FPS = Samples / Time = 30 / 0.84 = 35.8 FPS&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It looks like TensorRT makes a significant difference vs simply running the inference in Tensorflow! Stay tuned for my next steps on the Nano: implementing and optimizing MobileNet SSD object detection to run at 30+ FPS!&lt;/p&gt;

</description>
        <pubDate>Mon, 08 Apr 2019 07:00:00 -0500</pubDate>
        <link>https://csvance.github.io/blog/installing-tensorflow-tftrt-jetson-nano.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/installing-tensorflow-tftrt-jetson-nano.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Using the new Jetson.GPIO python library in Jetpack 4.2</title>
        <description>&lt;p&gt;With the release of the new &lt;a href=&quot;https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-nano/&quot;&gt;Jetson Nano&lt;/a&gt; also comes the &lt;a href=&quot;https://developer.nvidia.com/embedded/jetpack&quot;&gt;4.2 release of nVidia’s Jetpack BSP for the Jetson&lt;/a&gt;. This included a new python library called Jetson.GPIO which provides a familiar interface for anyone who has used RPi.GPIO before. However, it doesn’t seem to be installed by default, so here are the instructions for getting it loaded into python!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# Setup groups/permissions&lt;/span&gt;
sudo groupadd -f -r gpio
sudo usermod -a -G gpio your_user_name
sudo cp /opt/nvidia/jetson-gpio/etc/99-gpio.rules /etc/udev/rules.d/
sudo udevadm control --reload-rules &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo udevadm trigger

&lt;span class=&quot;c&quot;&gt;# Reboot required for changes to take effect&lt;/span&gt;
sudo reboot&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we need to install Jetson.GPIO:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo pip3 install Jetson.GPIO
sudo pip install Jetson.GPIO&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After this we should be able to import the library in both versions of python:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;nvidia@tx2:~$ &lt;/span&gt;python3
Python 3.6.7 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default, Oct 22 2018, 11:32:17&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GCC 8.2.0] on linux
Type &lt;span class=&quot;s2&quot;&gt;&quot;help&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;copyright&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;credits&quot;&lt;/span&gt; or &lt;span class=&quot;s2&quot;&gt;&quot;license&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more information.
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;import Jetson.GPIO
&amp;gt;&amp;gt;&amp;gt;
&lt;span class=&quot;gp&quot;&gt;nvidia@tx2:~$ &lt;/span&gt;python
Python 2.7.15rc1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default, Nov 12 2018, 14:31:15&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GCC 7.3.0] on linux2
Type &lt;span class=&quot;s2&quot;&gt;&quot;help&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;copyright&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;credits&quot;&lt;/span&gt; or &lt;span class=&quot;s2&quot;&gt;&quot;license&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more information.
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;import Jetson.GPIO
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Happy hacking!&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Mar 2019 07:00:00 -0500</pubDate>
        <link>https://csvance.github.io/blog/jetpack-42-jetson-gpio.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/jetpack-42-jetson-gpio.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Covariance Matrices in ROS</title>
        <description>&lt;p&gt;A common issue learning &lt;a href=&quot;http://www.ros.org&quot;&gt;ROS&lt;/a&gt; for those without a background in mathematics (specifically Statistics and Linear Algebra) is how to generate a covariance matrix for various message types, and why one needs to generate such a thing in the first place. Today I will attempt to explain both!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/covariance_matrix.png&quot; alt=&quot;Covariance Matrix&quot; /&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;b&gt;Covariance Matrix&lt;/b&gt;&lt;br /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;what-are-covariance-matrices-used-for-anyway&quot;&gt;What are covariance matrices used for anyway?&lt;/h2&gt;

&lt;p&gt;In robotics, a common problem is how to estimate the robot’s pose in three dimensional space. We need to know where the robot (starting with base_link) is in order to understand where the sensor readings take place. In ROS most things are relative to base_link so we if we don’t know where base_link is we don’t know where laser_scanner, camera, or any of our other sensors are! If we don’t know where the sensor is, we don’t know where the readings apply to in space. Covariance matrices help us with robotic state estimation problems in two different ways here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The diagonal of a covariance matrix is simply the variance of one of our sensor readings. By knowing the variance, we know a reasonable upper and lower bound of the error over time. This is important to know for using these readings to estimate other things.&lt;/li&gt;
  &lt;li&gt;State estimation algorithms can use the non diagonal entries (covariance) of the covariance matrix to reduce error in readings by understanding how things vary with other things. A positive covariance tells us that when one reading is high, the other one is likely to be as well. A negative covariance tells us the opposite.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;something-practical&quot;&gt;Something Practical&lt;/h2&gt;

&lt;p&gt;A practical example of a covariance matrix is using an IMU sensor to improve our estimation of our current position and heading. An IMU can help with this by letting the robot know how much it is accelerating and how fast it is rotating.&lt;/p&gt;

&lt;p&gt;Let’s look at the simplest possible case: a robot that lives in the X and Y dimensions. At T=0s, the robot is at (x=0, y=0), and our accelerometer is telling us we are accelerating at (x=1, y=0) m/s^2. At T=1s we see our acceleration remains constant, and want to know how far the robot moved and how fast it is going. Newton taught us that velocity is the derivative of position, and acceleration the derivative of velocity. Since we are working with numbers, we will need to use numerical integration techniques to determine our velocity V and position P from acceleration A. Because our acceleration is constant it forms a rectangle shape, so we can just multiply our ΔT by our acceleration (1 m/s^2). We find that our velocity V increases linearly by 1 m/s over 1 second. To get to position P We can calculate the area of the triangle under the linear velocity curve (1/2 base*height). This gives us a final position P of (x=0.5, y=0) m. Now consider how the covariance matrix can help us understand the error in this process, and eventually improve our estimation by combining the results from other sensors.&lt;/p&gt;

&lt;p&gt;Let’s start by looking at the variance of acceleration. In this particular case we found it to be (x=0.001, y=0.002). This means it has a standard deviation of (x=0.0316, y=0.0447) by taking the square root of the variance. We then add and subtract 1/2 the standard deviation from our linear accelerometer readings. This gives us a reasonable estimation of the real range of the acceleration A.&lt;/p&gt;

&lt;p&gt;Now we repeat the process of numerical integration with both our high and low estimates.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/covariance_example.png&quot; alt=&quot;Covariance Example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We have now calculated a possible range of estimates for velocity V and position P for our IMU. However, we have only accounted for a single time step. Because we are uncertain about our starting state for the next time step, the possible range of values balloons quickly, especially when one starts considering the direction the robot is facing during all of this.&lt;/p&gt;

&lt;p&gt;To improve our estimation we can use a second sensor and combine the results together. Our state estimator will look at the intersections of our different sensors estimations, and calculate the maximum likely value for each state we are estimating. So say we also had an estimation of our position from odometry, and there was some intersection between our IMU estimation. The true X and Y we are trying to estimate is most likely inside the intersection of these ranges.&lt;/p&gt;

&lt;p&gt;The concept for covariance is similar, but the details are far more complicated. Just know that state estimation systems such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Kalman_filter&quot;&gt;Extended Kalman Filters&lt;/a&gt; use this information to make better predictions about the state.&lt;/p&gt;

&lt;h2 id=&quot;how-to-calculate-a-sampling-covariance-matrix&quot;&gt;How to calculate a (sampling) covariance matrix?&lt;/h2&gt;

&lt;p&gt;Let’s consider the case of an IMU sensor again. We want to measure the sampling noise of the linear acceleration when it is completely still. We create a matrix A containing 3 rows (x, y, z) and 100 columns (individual readings). Next, we calculate the row mean of x, y, and z. We subtract each rows row mean from itself. This gives us a matrix B. Next, we matrix multiply B*B^T. Finally we divide the resulting matrix by n, the number of samples we recorded. This gives us a covariance matrix C.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/covariance_calculation.png&quot; alt=&quot;Covariance Calculation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When we multiply two matrices together, the result has the dimensions of their outside dimensions. So 3 x 100 * 100 x 3 = 3 x 3. So we now have a 3 x 3 covariance matrix, and we need to add it to our ROS IMU messages. The &lt;a href=&quot;http://docs.ros.org/api/sensor_msgs/html/msg/Imu.html&quot;&gt;IMU message&lt;/a&gt; in ROS contains an array called linear_acceleration_covariance which has 9 floating point values. We can simply reshape our matrix to a 9 element array, and store the values in linear_acceleration_covariance. In our covariance array, indexes 0, 4, and 8 (the diagonals) will contain variances, and the rest of the indexes contain covariances between variables.&lt;/p&gt;

&lt;p&gt;Keep in mind that this process is only taking into account sampling noise from the sensor, rather than inherent inaccuracies that may be present. It would be prudent to pad the variance for certain sources such as odometry due to factors such as wheel slippage.&lt;/p&gt;

&lt;p&gt;For an example of calculating a covariance matrix with a real sensor and data within a ROS node, see my &lt;a href=&quot;https://github.com/csvance/lsm9ds0/blob/master/src/lsm9ds0_node.py&quot;&gt;LSM9DS0 IMU ROS node&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Jan 2019 06:00:00 -0600</pubDate>
        <link>https://csvance.github.io/blog/covariance-matrices-in-ros.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/covariance-matrices-in-ros.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>TensorRT ROS Nodes for nVidia Jetson</title>
        <description>&lt;p&gt;During the past few months I have been working towards making high performance deep learning inferences much more accessible in &lt;a href=&quot;http://www.ros.org&quot;&gt;ROS&lt;/a&gt; on the &lt;a href=&quot;https://www.nvidia.com/en-us/autonomous-machines/embedded-systems-dev-kits-modules/&quot;&gt;nVidia Jetson TX2&lt;/a&gt;. The result is &lt;a href=&quot;https://github.com/csvance/jetson_tensorrt&quot;&gt;jetson_tensorrt&lt;/a&gt;: a collection of optimized &lt;a href=&quot;https://developer.nvidia.com/tensorrt&quot;&gt;TensoRT&lt;/a&gt; based nodes and nodelets specifically tailored to the Jetson platform. To start out with, classification and object detection are supported for &lt;a href=&quot;https://developer.nvidia.com/digits&quot;&gt;nVidia DIGITS&lt;/a&gt; ImageNet and DetectNets.&lt;/p&gt;

&lt;p&gt;Here is some example output in rviz from a single class pedestrian detector using an Intel RealSense D435:
&lt;img src=&quot;/assets/img/tensorrt_detect.jpg&quot; alt=&quot;detect&quot; /&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;b&gt;DetectNet Object Detection&lt;/b&gt;&lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;Support is planned for SegNets as well.&lt;/p&gt;

&lt;p&gt;Check it out on &lt;a href=&quot;https://github.com/csvance/jetson_tensorrt&quot;&gt;Github&lt;/a&gt;!&lt;/p&gt;

</description>
        <pubDate>Thu, 11 Oct 2018 07:00:00 -0500</pubDate>
        <link>https://csvance.github.io/blog/tensorrt-ros-nodes-nvidia-jetson.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/tensorrt-ros-nodes-nvidia-jetson.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Keras/Tensorflow, TensorRT, and Jetson</title>
        <description>&lt;p&gt;nVidia’s Jetson platform is arguably the most powerful family of devices for deep learning at the edge. In order to achieve the full benefits of the platform, a framework called TensorRT drastically reduces inference time for supported network architectures and layers. However, nVidia does not currently make it easy to take your existing models from Keras/Tensorflow and deploy them on the Jetson with TensorRT. One reason for this is the python API for TensorRT only supports x86 based architectures. This leaves us with no real easy way of taking advantage of the benefits of TensorRT. However, there is a harder way that does work: To achieve maximum inference performance we can export and convert our model to .uff format, and then load it in TensorRT’s C++ API.&lt;/p&gt;

&lt;h2 id=&quot;1-training-and-exporting-to-pb&quot;&gt;1. Training and exporting to .pb&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Train your model&lt;/li&gt;
  &lt;li&gt;If using Jupyter, restart the kernel you trained your model in to remove training layers from the graph&lt;/li&gt;
  &lt;li&gt;Reload the models weights&lt;/li&gt;
  &lt;li&gt;Use an export function like the one in &lt;a href=&quot;https://github.com/csvance/keras-tensorrt-jetson/blob/master/training/training.ipynb&quot;&gt;this notebook&lt;/a&gt; to export the graph to a .pb file&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-converting-pb-to-uff&quot;&gt;2. Converting .pb to .uff&lt;/h2&gt;
&lt;p&gt;I suggest using the &lt;a href=&quot;https://github.com/chybhao666/TensorRT&quot;&gt;chybhao666/cuda9_cudnn7_tensorrt3.0:latest Docker container&lt;/a&gt; to access the script needed for converting a .pb export from Keras/Tensorflow to .uff format for TensorRT import.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/lib/python2.7/dist-packages/uff/bin
# List Layers and manually pick out the output layer
# For most networks it will be dense_x/BiasAdd, the last one that isn't a placeholder or activation layer
python convert_to_uff.py tensorflow --input-file /path/to/graph.pb -l

# Convert to .uff, replace dense_1/BiasAdd with the name of your output layer
python convert_to_uff.py tensorflow -o /path/to/graph.uff --input-file /path/to/graph.pb -O dense_1/BiasAdd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;More information on the .pb export and .uff conversion is available from &lt;a href=&quot;https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#exporttftouff&quot;&gt;nVidia&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-loading-the-uff-into-tensorrt-c-inference-api&quot;&gt;3. Loading the .uff into TensorRT C++ Inference API&lt;/h2&gt;
&lt;p&gt;I have created a generic class which can load the graph from a .uff file and setup TensorRT for inference while taking care of all host / device CUDA memory management behind the scenes. It supports any number of inputs and outputs and is available on my &lt;a href=&quot;https://github.com/csvance/keras-tensorrt-jetson/blob/master/inference/&quot;&gt;Github&lt;/a&gt;. It can be built with &lt;a href=&quot;https://developer.nvidia.com/nsight-eclipse-edition&quot;&gt;nVidia nSight Eclipse Edition&lt;/a&gt; using a remote toolchain &lt;a href=&quot;https://devblogs.nvidia.com/remote-application-development-nvidia-nsight-eclipse-edition/&quot;&gt;(instructions here)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;caveats&quot;&gt;Caveats&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Keep in mind that many layers are not supported by TensorRT 3.0. The most obvious omission is BatchNorm, which is used in many different types of deep neural nets.&lt;/li&gt;
  &lt;li&gt;Concatenate only works on the channel axis and if and only if the other dimensions are the same. If you have multiple paths for convolution, you are limited to concatenating them only when they have the same dimensions.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 22 May 2018 22:00:00 -0500</pubDate>
        <link>https://csvance.github.io/blog/keras-tensorrt-jetson.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/keras-tensorrt-jetson.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Turn Based Games and 1v1 DQNs</title>
        <description>&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;At this point, one would have to be living under a rock to have not heard of &lt;a href=&quot;https://deepmind.com&quot;&gt;DeepMind’s&lt;/a&gt; success at teaching itself to play Go by playing itself without any feature engineering. However, most available tutorials online about &lt;a href=&quot;https://deepmind.com/research/dqn/&quot;&gt;Deep Q Networks&lt;/a&gt; are coming from an entirely different angle: learning how to play various single player games in the &lt;a href=&quot;https://github.com/openai/gym&quot;&gt;OpenAI Gym&lt;/a&gt;. If one simply applies these examples to turn based games in which the AI learns by playing itself, a world of hurt is in store for several reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In standard DQN learning, the target reward is retrieved by using the next state after an action is taken. However, the next state in a turned based dueling game is used by the enemy of the agent who took the action. To further complicate matters, the generated next state from an action is in the perspective of the agent taking the action. If we attempt to implement standard DQN, we are training the agent with data used in incorrect game contexts and assigning rewards for the wrong perspective.&lt;/li&gt;
  &lt;li&gt;Many turn based dueling games only have a win condition rather than a score which can be used for rewards. This complicates both measuring a DQN’s performance and assigning rewards.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;state-and-perspective&quot;&gt;State and Perspective&lt;/h2&gt;
&lt;p&gt;First of all, in a game where an agent plays itself from multiple perspectives, we must be careful the correct perspective is provided when making predictions or training discounted future rewards. For example, let us consider the game &lt;a href=&quot;https://en.wikipedia.org/wiki/Connect_Four&quot;&gt;Connect Four&lt;/a&gt;. Instead of viewing the game as a battle between a red agent and a black agent, we could consider it from the perspective the agents viewpoint at the state being considered. For example, when the agent who takes the second turn blocks the agent who went first, the following next state is generated:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/perspective_a.png&quot; alt=&quot;perspective&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However, this next state wouldn’t be used by the agent who went second to take an action. It is going to be used by the agent who went first, but it needs to be inverted to their perspective before it can be used:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/perspective_b.png&quot; alt=&quot;perspective&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However, this is not the only tweak needed to get DQN working with a dueling turn based game. Let us recall how the discounted future reward is calculated:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;future_reward = reward + gamma * amax(predict(next_state))&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;gamma: discount factor, for example 0.9&lt;/li&gt;
  &lt;li&gt;reward: the reward the agent recieved for taking an action&lt;/li&gt;
  &lt;li&gt;next_state: the state generated from applying an action to the original state&lt;/li&gt;
  &lt;li&gt;amax selects: highest value from the result&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Remember, next_state will be the enemy agent’s state. So if we simply implement this formula, we are predicting the discounted future reward that the enemy agent might receive, not our own. We must predict one more state into the future in order to propagate the discounted future reward:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;# We must invert the perspective of next_state so it is in the perspective of the enemy of the player who took the action which resulted in next_state&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;next_state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invert_perspective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Predict the action the enemy is most likely to take&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;enemy_action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Apply the action and invert the perspective back to the original one&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;true_next_state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next_state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enemy_action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;true_next_state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invert_perspective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Finally calculate discounted future reward&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;future_reward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gamma&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;true_next_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I have also tried subtracting the enemy reward from the reward that took the original action, but have not been able to measure good long or short term results with this policy.&lt;/p&gt;

&lt;h2 id=&quot;win-conditions-and-rewards&quot;&gt;Win Conditions and Rewards&lt;/h2&gt;
&lt;p&gt;Another problem with certain board games such as Connect Four is that they have no objective way of keeping score. There is only reward for victory and punishment for failure. I have had luck using 1.0 for victory, -1.0 for failure, and 0.0 for all other moves. Samples for duplicate games in a row and ties should be discarded as they don’t contain any useful information and will only serve to pollute our replay memory.&lt;/p&gt;

&lt;h2 id=&quot;measuring-performance&quot;&gt;Measuring Performance&lt;/h2&gt;
&lt;p&gt;One major challenge of DQNs with only win / loss conditions is measuring the networks performance over time. I have found a few ways to do this, including having the agent play a short term reward maximizing symbolic AI every N games as validation. If our agent cannot beat an agent that only thinks in the short term, then we need to continue making changes to the network structure, hyper-parameters, and feature representation. Beating this short sighted AI consistently should be our first goal.&lt;/p&gt;

&lt;h2 id=&quot;network-stability&quot;&gt;Network Stability&lt;/h2&gt;
&lt;p&gt;A common mistake creating a DQN is making the network have too few dimensions to begin with. This can cause serious aliasing in our predictions, resulting in an unstable network. Generally speaking, it is better to start with a wide network and testing how much the network can be slimmed down.&lt;/p&gt;

&lt;p&gt;We must also make sure our training data and labels are formatted in a way to ensure stability. Rewards should be normalized in the [-1., 1.] range, and any discounted future reward which is outside of this range should be clipped.&lt;/p&gt;

&lt;p&gt;Another factor in network stability is our experience replay buffer size. Too small and our network will forget past things it learned, and too big and it will take excessive time to learn. I find it is generally its better to start smaller while testing if the network is able to learn simple gameplay, and increasing it as training time increases and we want to insure network stability. People smarter than I such as Schaul et al. (2017) have proposed methods to optimize the size of the experience replay buffer: &lt;a href=&quot;https://arxiv.org/abs/1511.05952&quot;&gt;Prioritized Experience Replay&lt;/a&gt; which may be worth investigating if you are unsure how to tune this.&lt;/p&gt;

&lt;p&gt;Another factor to consider is the optimizer learning rate. A high learning rate can create instabilities in the neural networks state approximation behavior, resulting in all kinds of catastrophic forgetfulness. Starting at 0.001 is a good idea, and if you note instabilities with this try decreasing it from there. I find that 0.0001 works optimally for longer training sessions.&lt;/p&gt;

&lt;p&gt;Finally, techniques used in deep neural networks such as dropout and batchnorm have a negative impact on Deep-Q Learning. I suggest watching &lt;a href=&quot;https://www.youtube.com/watch?v=fevMOp5TDQs&quot;&gt;Deep RL Bootcamp Lecture 3: Deep Q-Networks&lt;/a&gt; if you are interested in more information on this.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Deep Q Learning proves to be both extremely interesting and challenging. While I am not completely happy with my own results in training a DQN for Connect Four, I think it is at least worth posting some of the things I have learned from the experience. My current agent can be found at the link below.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/csvance/deep-learning-connect-four&quot;&gt;Github: DQN AI for Connect Four&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://keon.io/deep-q-learning/&quot;&gt;Deep Q-Learning with Keras and Gym&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=fevMOp5TDQs&quot;&gt;Deep RL Bootcamp Lecture 3: Deep Q-Networks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 09 Jan 2018 12:04:00 -0600</pubDate>
        <link>https://csvance.github.io/blog/turn-based-games-1v1-dqn.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/turn-based-games-1v1-dqn.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>The RNN Sequence Prediction Seed Problem and How To Solve It</title>
        <description>&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;There are many &lt;a href=&quot;https://machinelearningmastery.com/text-generation-lstm-recurrent-neural-networks-python-keras/&quot;&gt;tutorials&lt;/a&gt; on how to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrent_neural_network&quot;&gt;Recurrent Neural Networks&lt;/a&gt; and use them for sequence generation. However, most of these tutorials show an example where an initial seed value must be used to start the generation process. This is highly impractical for a query response generation scheme. Luckily, there is a fairly easy way to solve this involving how we format our training data.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;h3 id=&quot;empty-item&quot;&gt;Empty Item&lt;/h3&gt;
&lt;p&gt;First of all, we need to make sure we have a dummy value which represents an empty sequence item. It is convenient to use zero for this, because most padding functions are going to pad with zeros, and functions like np.zeros make it easy to initialize this. We will represent this value as NULL for simplicity.&lt;/p&gt;
&lt;h3 id=&quot;end-of-sequence-item&quot;&gt;End of Sequence Item&lt;/h3&gt;
&lt;p&gt;We need a second special value for marking the end of a sequence. Call it EOS for short, and it can be whatever value you want provided it stays consistent.&lt;/p&gt;
&lt;h3 id=&quot;sequence-steps&quot;&gt;Sequence Steps&lt;/h3&gt;
&lt;p&gt;Instead of feeding entire sequences for training, we are going to step through each sequence, generating subsequences starting with all empty values and adding one more item in each step. The label for each sequence will simply be the next word in the sequence, or &lt;EOS&gt; if we reach the end of the sequence. For example, take the sequence &quot;The quick brown fox jumps over the lazy dog. This will break down into the following sequences:&lt;/EOS&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
&quot;NULL NULL NULL NULL NULL NULL NULL NULL NULL&quot; -&amp;gt; The
&quot;The NULL NULL NULL NULL NULL NULL NULL NULL&quot; -&amp;gt; quick
&quot;The quick NULL NULL NULL NULL NULL NULL NULL&quot; -&amp;gt; brown
&quot;The quick brown NULL NULL NULL NULL NULL NULL&quot; -&amp;gt; fox
&quot;The quick brown fox NULL NULL NULL NULL NULL&quot; -&amp;gt; jumps
&quot;The quick brown fox jumps NULL NULL NULL NULL&quot; -&amp;gt; over
&quot;The quick brown fox jumps over NULL NULL NULL&quot; -&amp;gt; the
&quot;The quick brown fox jumps over the NULL NULL&quot; -&amp;gt; lazy
&quot;The quick brown fox jumps over the lazy NULL&quot; -&amp;gt; dog
&quot;The quick brown fox jumps over the lazy dog&quot; -&amp;gt; EOS
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;sequence-size&quot;&gt;Sequence Size&lt;/h3&gt;
&lt;p&gt;If you have a sequence larger than your maximum size, start removing the first element before you append a new one. This will have no bearing on prediction because the network will learn how to handle this.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We can now train the network and start by feeding it a sequence filled with NULLs to predict the first value. Here is an example doing this using &lt;a href=&quot;https://keras.io&quot;&gt;Keras&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/csvance/armchair-expert/blob/master/models/structure.py&quot;&gt;Preprocessing &amp;amp; Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 29 Dec 2017 12:04:00 -0600</pubDate>
        <link>https://csvance.github.io/blog/RNN-seed-problem.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/RNN-seed-problem.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Hello World!</title>
        <description>&lt;p&gt;Hi, and welcome to my portfolio and blog. I will be chronicling my explorations in machine learning, artificial intelligence, and software engineering here.&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Dec 2017 13:40:48 -0600</pubDate>
        <link>https://csvance.github.io/blog/hello-world.html</link>
        <guid isPermaLink="true">https://csvance.github.io/blog/hello-world.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
